<?php

/**
 * Implements hook_form_FORM_ID_alter.
 */
function scratchpads_biblio_form_node_form_alter(&$form, &$form_state, $form_id){
  if($form_id == 'biblio_node_form' && arg(2) == 'clone'){
    $form_state['biblio_type'] = 'set biblio type so that we can save!';
  }
}

/**
 * Implements hook_module_implements_alter.
 */
function scratchpads_biblio_module_implements_alter(&$implementations, $hook){
  if($hook == 'form_alter' && isset($implementations['scratchpads_biblio'])){
    $new_implementations = array();
    $new_implementations['scratchpads_biblio'] = $implementations['scratchpads_biblio'];
    unset($implementations['scratchpads_biblio']);
    foreach($implementations as $key => $value){
      $new_implementations[$key] = $value;
    }
    $implementations = $new_implementations;
  }
}

/**
 * Implements hook_menu_alter().
 */
function scratchpads_biblio_menu_alter(&$items){
  $items['admin/config/content/biblio'] = $items['admin/config/content/biblio/iomap'];
  $items['admin/config/content/biblio']['title'] = 'Biblio settings';
  $items['admin/config/content/biblio']['type'] = MENU_NORMAL_ITEM;
  $items['admin/config/content/biblio/iomap'] = array(
    'title' => 'Import/Export Mapping',
    'type' => MENU_DEFAULT_LOCAL_TASK
  );
}

/**
 * Implements hook_node_presave().
 * 
 * Prevent biblio nodes from being saved with a title.
 */
function scratchpads_biblio_node_presave($node){
  if($node->type == 'biblio'){
    // Set a title if it is blank.
    if(!isset($node->title)){
      $node->title = t('[TITLE BLANK]');
    }
    if(isset($node->biblio_keywords) && count($node->biblio_keywords) && ($vids = array_keys(array_filter(variable_get('biological_vids', array()))))){
      // Associate this record with terms in any vocabulary.
      $results = db_select('taxonomy_term_data', 't')->fields('t', array(
        'tid'
      ))->condition('vid', $vids)->condition('name', $node->biblio_keywords)->execute();
      foreach($results as $row){
        $node->field_taxonomic_name[LANGUAGE_NONE][] = (array)taxonomy_term_load($row->tid);
      }
    }
  }
  return $node;
}

/**
 * Implements hook_field_formatter_info().
 */
function scratchpads_biblio_field_formatter_info(){
  return array(
    'scratchpads_biblio_biblio_ref' => array(
      'label' => t('Citation'),
      'description' => t("Properly formatted citation using the site's style"),
      'field types' => array(
        'node_reference'
      )
    )
  );
}

/**
 * Implements hook_field_formatter_view().
 * 
 * For a node_reference that links to a Biblio node returns a link to the URL field as either a predefined image
 * or the favicon of the site that is linked to.
 * 
 * For all node types returns link to attached files as an image 
 */
function scratchpads_biblio_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display){
  $element = array();
  switch($display['type']){
    case 'scratchpads_biblio_biblio_ref':
      foreach($items as $delta => $item){
        $node = node_load($item['nid'], NULL, FALSE);
        if($node->type == 'biblio'){
          $output = theme('biblio_style', array(
            'node' => $node,
            'style_name' => biblio_get_style()
          ));
          $element[] = array(
            '#markup' => $output
          );
        }
      }
      break;
  }
  return $element;
}

/**
 * Implements hook_filter_info_alter().
 */
function scratchpads_biblio_filter_info_alter(&$info){
  $info['biblio_filter_reference']['process callback'] = '_scratchpads_biblio_filter_reference_process';
}

/**
 * Helper function
 * Altered version of _biblio_filter_reference_process in biblio module
 * Altered to allow the calling of _scratchpads_biblio_filter_replace_callback() in place of _biblio_filter_replace_callback()
 */
function _scratchpads_biblio_filter_reference_process($text, $filter, $format, $langcode, $cache, $cache_id){
  $pattern = array(
    '|\[bib](.*?)\[/bib]|s',
    '|<bib>(.*?)</bib>|s'
  );
  if(variable_get('biblio_footnotes_integration', 0) && module_exists('footnotes')){
    $text = preg_replace_callback($pattern, '_biblio_filter_footnote_callback', $text);
    return $text;
  }else{
    $text = preg_replace_callback($pattern, '_scratchpads_biblio_filter_replace_callback', $text);
    $footer = '';
    $footer = _scratchpads_biblio_filter_replace_callback(NULL, 'output footer');
    if(preg_match('/<bibliography(\/( )?)?>/', $text) > 0){
      $text = preg_replace('/<bibliography(\/( )?)?>/', $footer, $text, 1);
      return $text;
    }else{
      return $text . "\n\n" . $footer;
    }
  }
}

/**
 * Helper function. 
 * Altered version of _biblio_filter_replace_callback() function in biblio module.
 * Altered to allow the addition of descriptive link titles of the form: 'Citation id. Author(s), Year, Title'
 */
function _scratchpads_biblio_filter_replace_callback($matches, $op = ''){
  static $n = 0;
  static $store_matches = array();
  $hover_descriptions = array();
  $str = '';
  if($op == 'output footer'){
    if($n > 0){
      $str = '<hr /><h3>' . t('References') . '</h3>';
      $str .= '<div class="references"><ol>';
      for($m = 1; $m <= $n; $m++){
        $str .= '<li id="reference' . $m . '"><a name="ref' . $m . '">' . _biblio_citekey_print($store_matches[$m - 1]) . " </a></li>\n\n";
      }
      $str .= '</ol></div>';
    }
    $n = 0;
    $store_matches = array();
    return $str;
  }
  $ref = array_search($matches[1], $store_matches);
  if($ref === FALSE){
    $n++;
    array_push($store_matches, $matches[1]);
    $ref = $n;
  }else{
    $ref++;
  }
  for($m = 1; $m <= $n; $m++){
    $hover_descriptions[$m] = _scratchpads_biblio_citekey($store_matches[$m - 1]);
  }
  $allowed_tags = array();
  $title = filter_xss($matches[1], biblio_get_allowed_tags());
  $title = str_replace('"', "&quot;", $title);
  $title = str_replace("\n", " ", $title);
  $title = str_replace("\r", "", $title);
  $text = '<span hovertip="reference' . $ref . '"><a href="#ref' . $ref . '">[' . $ref . ']</a></span>';
  if(module_exists('hovertip')){
    $text = '<span hovertip="reference' . $ref . '"><a href="#ref' . $ref . '">[' . $ref . ']</a></span>';
    $text .= '<span id="reference' . $ref . '" class="hovertip">' . _biblio_citekey_print($title) . '</span>';
  }else{
    $text = '<a href="#ref' . $ref . '" title="' . $hover_descriptions[$ref] . '">[' . $ref . ']</a>';
  }
  return $text;
}

/**
 * Helper function
 * Returns a formatted string for a biblio citation
 * Author(s), Year, Title
 */
function _scratchpads_biblio_citekey($citekey){
  $nid = db_query("SELECT nid FROM {biblio} WHERE biblio_citekey = :key", array(
    ':key' => $citekey
  ))->fetchObject();
  if($nid->nid > 0){
    $node = node_load($nid->nid);
    $authors = array();
    $author_count = 0;
    foreach($node->biblio_contributors as $author){
      if(!empty($author['lastname'])){
        $authors[] = $author['lastname'];
        $author_count++;
      }
    }
    switch($author_count){
      case 0:
        $author_string = '';
        break;
      case 1:
        $author_string = $authors[0] . ', ';
        break;
      case 2:
        $author_string = $authors[0] . ' and ' . $authors[1] . ', ';
        break;
      case 3:
        $author_string = $authors[0] . ', ' . $authors[1] . ', and ' . $authors[2] . ' , ';
        break;
      default:
        $author_string = $authors[0] . ' et al.' . ', ';
    }
    if(isset($node->biblio_year)){
      $year = $node->biblio_year . ', ';
    }else{
      $year = '';
    }
    if(isset($node->title)){
      $title = $node->title;
    }else{
      $title = '';
    }
    return $author_string . $year . $title . '.';
  }else{
    return t("Citekey @cite not found", array('@cite' => $citekey));
  }
}

